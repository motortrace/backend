generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// User Profile - extends Supabase auth.users
// Only stores additional profile data, not identity data
model UserProfile {
  id             String        @id @default(cuid())
  supabaseUserId String        @unique @db.Uuid // Links to auth.users.id (FK constraint added via migration)
  name           String?
  phone          String?
  profileImage   String?
  role           UserRole      @default(CUSTOMER)
  isRegistrationComplete Boolean @default(false)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // Relations
  customer       Customer?
  serviceAdvisor ServiceAdvisor?
  technician     Technician?
  inventoryManager InventoryManager?
  manager        Manager?
  admin          Admin?
  uploadedAttachments WorkOrderAttachment[] @relation("UploadedAttachments")
  uploadedInspectionAttachments WorkOrderInspectionAttachment[] @relation("UploadedInspectionAttachments")
  notifications  Notification[]
}

model ServiceAdvisor {
  id             String        @id @default(cuid())
  userProfile    UserProfile   @relation(fields: [userProfileId], references: [id])
  userProfileId  String        @unique
  employeeId     String?       @unique
  department     String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // Relations
  advisorWorkOrders WorkOrder[] @relation("AdvisorWorkOrders")
  assignedAppointments Appointment[] @relation("AssignedAppointments")
  approvals      WorkOrderApproval[] @relation("Approvals")
  processedPayments Payment[] @relation("ProcessedPayments")
}

model Technician {
  id             String        @id @default(cuid())
  userProfile    UserProfile   @relation(fields: [userProfileId], references: [id])
  userProfileId  String        @unique
  employeeId     String?       @unique
  specialization String?
  certifications String[]
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // Relations
  inspections    WorkOrderInspection[] @relation("Inspections")
  qcChecks       WorkOrderQC[] @relation("QCInspections")
  laborItems     WorkOrderLabor[] @relation("LaborWork")
  partInstallations WorkOrderPart[] @relation("PartInstallations")
}

model InventoryManager {
  id             String        @id @default(cuid())
  userProfile    UserProfile   @relation(fields: [userProfileId], references: [id])
  userProfileId  String        @unique
  employeeId     String?       @unique
  department     String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
}

model Manager {
  id             String        @id @default(cuid())
  userProfile    UserProfile   @relation(fields: [userProfileId], references: [id])
  userProfileId  String        @unique
  employeeId     String?       @unique
  department     String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
}

model Admin {
  id             String        @id @default(cuid())
  userProfile    UserProfile   @relation(fields: [userProfileId], references: [id])
  userProfileId  String        @unique
  employeeId     String?       @unique
  permissions    String[]
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
}

// Customer table supports both app users and walk-ins
// For app users: userProfileId points to their UserProfile
// For walk-ins: userProfileId is NULL
model Customer {
  id            String        @id @default(cuid())
  userProfile   UserProfile?  @relation(fields: [userProfileId], references: [id])
  userProfileId String?       @unique // Nullable to support walk-ins
  name          String        @db.VarChar(255)
  email         String?       // Optional for walk-ins, not unique to allow duplicates
  phone         String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  vehicles      Vehicle[]
  workOrders    WorkOrder[]
  appointments  Appointment[]
}

model Vehicle {
  id           String        @id @default(cuid())
  customer     Customer      @relation(fields: [customerId], references: [id])
  customerId   String
  make         String
  model        String
  year         Int?
  vin          String?       @unique
  licensePlate String?
  imageUrl     String?       // URL to vehicle image stored in Supabase Storage
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  workOrders   WorkOrder[]
  appointments Appointment[]
}

model WorkOrder {
  id              String         @id @default(cuid())
  workOrderNumber String         @unique
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  customer        Customer       @relation(fields: [customerId], references: [id])
  customerId      String
  vehicle         Vehicle        @relation(fields: [vehicleId], references: [id])
  vehicleId       String

  appointment     Appointment?   @relation(fields: [appointmentId], references: [id])
  appointmentId   String?        @unique

  serviceAdvisor  ServiceAdvisor?   @relation("AdvisorWorkOrders", fields: [advisorId], references: [id])
  advisorId       String?

  status          WorkOrderStatus
  jobType         JobType        @default(REPAIR)
  priority        JobPriority    @default(NORMAL)
  source          JobSource      @default(WALK_IN)
  complaint       String?
  odometerReading Int?
  warrantyStatus  WarrantyStatus @default(NONE)

  estimatedTotal  Decimal?       @db.Decimal(10,2)
  estimateNotes   String?
  estimateApproved Boolean       @default(false)

  // Pricing breakdown
  subtotalServices Decimal?      @db.Decimal(10,2)  // Sum of WorkOrderService.subtotal
  subtotalParts   Decimal?       @db.Decimal(10,2)  // Sum of WorkOrderPart.subtotal
  subtotal        Decimal?       @db.Decimal(10,2)  // subtotalServices + subtotalParts
  
  // Discount (applied at work order level only)
  discountAmount  Decimal?       @db.Decimal(10,2)
  discountType    String?        // "FIXED" or "PERCENTAGE"
  discountReason  String?        // Reason for discount (e.g., "Loyal customer", "Promotional offer")
  
  taxAmount       Decimal?       @db.Decimal(10,2)
  totalAmount     Decimal?       @db.Decimal(10,2)
  paidAmount      Decimal?       @db.Decimal(10,2) @default(0)

  openedAt        DateTime?
  promisedAt      DateTime?
  closedAt        DateTime?

  workflowStep    WorkflowStep   @default(RECEIVED)
  internalNotes   String?
  customerNotes   String?

  invoiceNumber   String?
  finalizedAt     DateTime?
  paymentStatus   PaymentStatus  @default(PENDING)

  warrantyClaimNumber      String?
  thirdPartyApprovalCode   String?

  campaignId       String?
  servicePackageId String?

  customerSignature String?
  customerFeedback  String?

  // Relations to be defined
  inspections     WorkOrderInspection[]
  approvals       WorkOrderApproval[]
  qcChecks        WorkOrderQC[]
  attachments     WorkOrderAttachment[]
  payments        Payment[]
  services        WorkOrderService[]
  laborItems     WorkOrderLabor[]
  partsUsed       WorkOrderPart[]
  invoices        Invoice[]
  notifications   Notification[]
}

// Renamed from ServiceCatalog to CannedService for ShopMonkey-style terminology
model CannedService {
  id          String         @id @default(cuid())
  code        String         @unique
  name        String
  description String?
  duration    Int            // Estimated labor time in minutes
  price       Decimal        @db.Decimal(10,2)
  isAvailable Boolean        @default(false)  // Only show these in booking UI
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Relations to actual work orders
  appointmentServices AppointmentCannedService[]
  services     WorkOrderService[]
  
  // Junction table relationships
  laborOperations CannedServiceLabor[]
  partsCategories CannedServicePartsCategory[]
}

// Junction table for CannedService to LaborCatalog (many-to-many)
model CannedServiceLabor {
  id             String        @id @default(cuid())
  cannedService  CannedService @relation(fields: [cannedServiceId], references: [id], onDelete: Cascade)
  cannedServiceId String
  laborCatalog   LaborCatalog  @relation(fields: [laborCatalogId], references: [id], onDelete: Cascade)
  laborCatalogId String
  sequence       Int           @default(1) // Order of operations
  estimatedMinutes Int?        // Estimated time for this labor operation in minutes
  notes          String?       // Additional notes for this labor operation
  
  @@unique([cannedServiceId, laborCatalogId])
}

// Junction table for CannedService to InventoryCategory (many-to-many)
model CannedServicePartsCategory {
  id             String        @id @default(cuid())
  cannedService  CannedService @relation(fields: [cannedServiceId], references: [id], onDelete: Cascade)
  cannedServiceId String
  category       InventoryCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId     String
  isRequired     Boolean       @default(true) // Whether this category is required or optional
  notes          String?       // Additional notes for this parts category
  
  @@unique([cannedServiceId, categoryId])
}

// Individual labor operations that technicians perform (TRACKING ONLY - NO PRICES)
// Examples: "Oil Drain & Fill", "Filter Installation", "Brake Inspection"
model LaborCatalog {
  id          String         @id @default(cuid())
  code        String         @unique
  name        String
  description String?
  
  // Time estimation (for scheduling only, NOT for billing)
  estimatedMinutes Int?       // Estimated time in minutes (e.g., 30, 45, 90)
  
  category    String?        // e.g., "Engine", "Brakes", "Electrical", "Diagnostic"
  skillLevel  String?        // e.g., "Basic", "Intermediate", "Advanced"
  isActive    Boolean        @default(true)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Relations
  cannedServices CannedServiceLabor[] // Services that use this labor operation
  laborItems WorkOrderLabor[]
}

// Shop Operating Hours and Capacity Planning
model ShopOperatingHours {
  id          String    @id @default(cuid())
  dayOfWeek   DayOfWeek @unique
  isOpen      Boolean   @default(false)
  openTime    String?   // Format: "08:00" for 8 AM
  closeTime   String?   // Format: "17:00" for 5 PM
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model ShopCapacitySettings {
  id                          String  @id @default(cuid())
  appointmentsPerDay          Int     @default(6)
  appointmentsPerTimeBlock    Int     @default(2)
  timeBlockIntervalMinutes    Int     @default(30)
  minimumNoticeHours          Int     @default(48)
  futureSchedulingCutoffYears Int     @default(3)
  createdAt                   DateTime @default(now())
  updatedAt                   DateTime @updatedAt
}

enum DayOfWeek {
  SUNDAY
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
}

model InventoryItem {
  id          String        @id @default(cuid())
  name        String
  sku         String?       @unique
  partNumber     String?    @unique
  manufacturer   String?
  location       String?    // Shelf location
  quantity    Int           @default(0)
  minStockLevel  Int?       @default(0)
  maxStockLevel  Int?       @default(0)
  reorderPoint   Int?       @default(0)
  unitPrice   Decimal       
  supplier       String?
  supplierPartNumber String?
  core           Boolean    @default(false) // Core charge applicable
  corePrice      Decimal?   @db.Decimal(10,2)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  category InventoryCategory @relation(fields: [categoryId], references: [id])
  categoryId   String
  
  // Relations
  workOrderParts WorkOrderPart[]
}

enum UserRole {
  CUSTOMER
  ADMIN
  MANAGER
  SERVICE_ADVISOR
  INVENTORY_MANAGER
  TECHNICIAN
}



enum WorkOrderStatus {
  PENDING           // Work order created, no items added yet
  AWAITING_APPROVAL // Services/parts added, waiting for customer approval
  APPROVED          // Customer approved all services/parts
  IN_PROGRESS       // Work has started (at least one service or part in progress)
  COMPLETED         // All work finished
  INVOICED          // Invoice generated
  PAID              // Payment received
  CANCELLED         // Work order cancelled
}

enum JobType {
  REPAIR
  MAINTENANCE
  INSPECTION
  WARRANTY
  RECALL
}

enum JobPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum JobSource {
  WALK_IN
  APPOINTMENT
  PHONE
  ROADSIDE_ASSIST
}

enum WarrantyStatus {
  NONE
  MANUFACTURER
  EXTENDED
}

// Appointment management - Updated for ShopMonkey-style scheduling
model Appointment {
  id           String            @id @default(cuid())
  customer     Customer          @relation(fields: [customerId], references: [id])
  customerId   String
  vehicle      Vehicle           @relation(fields: [vehicleId], references: [id])
  vehicleId    String
  requestedAt  DateTime
  startTime    DateTime?
  endTime      DateTime?
  status       AppointmentStatus @default(PENDING)
  priority     AppointmentPriority @default(NORMAL)
  notes        String?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  // Relations
  workOrder    WorkOrder?
  assignedTo   ServiceAdvisor?      @relation("AssignedAppointments", fields: [assignedToId], references: [id])
  assignedToId String?
  
  // Link to CannedServices (many-to-many relationship)
  cannedServices AppointmentCannedService[]
}

// Junction table for Appointment to CannedService relationship
model AppointmentCannedService {
  id             String        @id @default(cuid())
  appointment    Appointment   @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  appointmentId  String
  cannedService  CannedService @relation(fields: [cannedServiceId], references: [id], onDelete: Cascade)
  cannedServiceId String
  quantity       Int           @default(1)
  price          Decimal       @db.Decimal(10,2) // Price at time of booking
  notes          String?       // Additional notes for this service
  
  @@unique([appointmentId, cannedServiceId])
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum AppointmentPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// Inspection & Diagnostic Reports
// Inspection Templates - Predefined inspection categories and items
model InspectionTemplate {
  id          String   @id @default(cuid())
  name        String   @unique // "Engine (Mechanical Condition)", "Cooling System", etc.
  description String?  // Detailed description of what this template covers
  category    String?  // "Mechanical", "Electrical", "Safety", etc.
  imageUrl    String?  // URL to template image stored in Supabase bucket
  isActive    Boolean  @default(true)
  sortOrder   Int?     // Display order in UI
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  templateItems InspectionTemplateItem[]
  workOrderInspections WorkOrderInspection[] // Which inspections used this template
}

model InspectionTemplateItem {
  id               String             @id @default(cuid())
  template         InspectionTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  templateId       String
  name             String             // "Oil in air cleaner", "Water in oil", "Coolant level"
  description      String?            // More detailed description of what to check
  category         String?            // Sub-category within the template
  sortOrder        Int?               // Order within the template
  isRequired       Boolean            @default(true) // Must this item be checked?
  allowsNotes      Boolean            @default(true) // Can technician add notes?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt

  // Relations
  checklistResults InspectionChecklistItem[] // Actual inspection results using this template item

  @@unique([templateId, name]) // Prevent duplicate items within same template
}

// Updated WorkOrderInspection to link to templates
model WorkOrderInspection {
  id           String              @id @default(cuid())
  workOrder    WorkOrder           @relation(fields: [workOrderId], references: [id])
  workOrderId  String
  inspector    Technician?         @relation("Inspections", fields: [inspectorId], references: [id])
  inspectorId  String?
  template     InspectionTemplate? @relation(fields: [templateId], references: [id]) // NEW: Link to template used
  templateId   String?             // NEW: Template used for this inspection
  date         DateTime            @default(now())
  notes        String?             // Overall inspection summary
  isCompleted  Boolean             @default(false) // NEW: Track completion status
  
  // Relations
  checklistItems InspectionChecklistItem[]
  tireChecks    TireInspection[]
  attachments   WorkOrderInspectionAttachment[]
}

// Updated InspectionChecklistItem to reference template items
model InspectionChecklistItem {
  id                    String                  @id @default(cuid())
  inspection            WorkOrderInspection     @relation(fields: [inspectionId], references: [id])
  inspectionId          String
  templateItem          InspectionTemplateItem? @relation(fields: [templateItemId], references: [id]) // NEW: Link to template
  templateItemId        String?                 // NEW: Template item this result is based on
  
  // Keep these for backwards compatibility and custom items
  category              String?                 // e.g., "Engine", "Brakes" (from template or manual)
  item                  String                  // e.g., "Oil Level" (from template or manual)
  
  status                ChecklistStatus         // GREEN, YELLOW, RED
  notes                 String?                 // Technician's specific notes
  requiresFollowUp      Boolean                 @default(false) // NEW: Does this need follow-up?
  createdAt             DateTime                @default(now())

  @@unique([inspectionId, templateItemId]) // Prevent duplicate results for same template item
}

enum ChecklistStatus {
  GREEN    // Good condition
  YELLOW   // Needs attention
  RED      // Critical issue
}

model TireInspection {
  id           String     @id @default(cuid())
  inspection   WorkOrderInspection @relation(fields: [inspectionId], references: [id])
  inspectionId String
  position     TirePosition
  brand        String?    // Tire brand
  model        String?    // Tire model
  size         String?    // Tire size (e.g., "205/55R16")
  psi          Int?       // Current PSI
  treadDepth   Decimal?   @db.Decimal(4,2) // Tread depth in mm
  damageNotes  String?    // Any damage or wear notes
  createdAt    DateTime   @default(now())
}

enum TirePosition {
  LF      // Left Front
  RF      // Right Front
  LR      // Left Rear
  RR      // Right Rear
  SPARE   // Spare Tire
}

model WorkOrderInspectionAttachment {
  id           String     @id @default(cuid())
  inspection   WorkOrderInspection @relation(fields: [inspectionId], references: [id])
  inspectionId String
  fileUrl      String
  fileName     String?    // Original filename
  fileType     String?    // e.g., "image/jpeg", "application/pdf"
  fileSize     Int?       // File size in bytes
  description  String?    // Description of what the attachment shows
  uploadedBy   UserProfile? @relation("UploadedInspectionAttachments", fields: [uploadedById], references: [id])
  uploadedById String?
  uploadedAt   DateTime   @default(now())
}

// Labor & Parts Usage
model WorkOrderLabor {
  id               String          @id @default(cuid())
  workOrder        WorkOrder       @relation(fields: [workOrderId], references: [id])
  workOrderId      String
  
  // Parent service (REQUIRED - labor must belong to a service)
  service          WorkOrderService @relation(fields: [serviceId], references: [id])
  serviceId        String
  
  laborCatalog     LaborCatalog?   @relation(fields: [laborCatalogId], references: [id])
  laborCatalogId   String?         // Optional - for catalog-based labor operations
  description      String          // Description of the labor performed
  
  // NO PRICING - labor is for tracking only, not billing!
  // Customer pays for the parent service, not individual labor operations
  
  technician       Technician?    @relation("LaborWork", fields: [technicianId], references: [id])
  technicianId     String?
  
  // Time tracking (for scheduling and performance metrics)
  estimatedMinutes Int?            // Estimated time in minutes
  startTime        DateTime?       // When the work started
  endTime          DateTime?       // When the work ended
  actualMinutes    Int?            // Actual time taken (calculated from start/end)
  
  status           ServiceStatus  @default(PENDING) // Status of the labor work
  notes            String?         // Additional notes about the labor
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
}

model WorkOrderPart {
  id               String        @id @default(cuid())
  workOrder        WorkOrder     @relation(fields: [workOrderId], references: [id])
  workOrderId      String
  
  // NO serviceId - parts are independent, not tied to services
  
  part             InventoryItem @relation(fields: [inventoryItemId], references: [id])
  inventoryItemId  String
  description      String?       // Additional description if needed
  quantity         Int           @default(1)
  unitPrice        Decimal       @db.Decimal(10,2) // Price at time of use
  subtotal         Decimal       @db.Decimal(10,2) // quantity * unitPrice
  
  // Customer approval status
  customerApproved Boolean       @default(false)
  customerRejected Boolean       @default(false)
  customerNotes    String?       // Customer feedback on this part
  
  // Timestamps
  approvedAt       DateTime?     // When customer approved
  rejectedAt       DateTime?     // When customer rejected
  
  source           PartSource    @default(INVENTORY)
  supplierName     String?       // Supplier name if not from inventory
  supplierInvoice  String?       // Supplier invoice number
  warrantyInfo     String?       // Warranty information for the part
  notes            String?       // Internal notes
  installedAt      DateTime?     // When the part was installed
  installedBy      Technician?   @relation("PartInstallations", fields: [installedById], references: [id])
  installedById    String?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  
  @@index([workOrderId])
  @@index([customerApproved])
}


model WorkOrderApproval {
  id           String       @id @default(cuid())
  workOrder    WorkOrder    @relation(fields: [workOrderId], references: [id])
  workOrderId  String
  status       ApprovalStatus
  requestedAt  DateTime     @default(now())
  approvedAt   DateTime?
  approvedBy   ServiceAdvisor? @relation("Approvals", fields: [approvedById], references: [id])
  approvedById String?
  method       ApprovalMethod?
  notes        String?      // Notes from the approval process
  customerSignature String? // URL to signature file or signature data
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
}

enum ApprovalStatus {
  PENDING
  APPROVED
  DECLINED
  EXPIRED
}

enum ApprovalMethod {
  IN_PERSON
  PHONE
  EMAIL
  APP
  SMS
  DIGITAL_SIGNATURE
}

enum PartSource {
  INVENTORY        // From shop inventory
  SUPPLIER         // Ordered from supplier
  CUSTOMER_SUPPLIED // Customer provided the part
  WARRANTY         // Warranty replacement
  SALVAGE          // Used/salvage part
}

// QC, Attachments & Payments
model WorkOrderQC {
  id           String     @id @default(cuid())
  workOrder    WorkOrder  @relation(fields: [workOrderId], references: [id])
  workOrderId  String
  passed       Boolean    // QC pass/fail status
  inspector    Technician? @relation("QCInspections", fields: [inspectorId], references: [id])
  inspectorId  String?
  notes        String?    // QC notes and findings
  qcDate       DateTime   @default(now()) // When QC was performed
  reworkRequired Boolean  @default(false) // If rework is needed
  reworkNotes  String?    // Notes about required rework
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
}

model WorkOrderAttachment {
  id           String     @id @default(cuid())
  workOrder    WorkOrder  @relation(fields: [workOrderId], references: [id])
  workOrderId  String
  fileUrl      String     // URL to the stored file
  fileName     String?    // Original filename
  fileType     String     // MIME type (e.g., "image/jpeg", "application/pdf")
  fileSize     Int?       // File size in bytes
  description  String?    // Description of what the attachment shows
  category     AttachmentCategory @default(GENERAL) // Category of attachment
  uploadedBy   UserProfile? @relation("UploadedAttachments", fields: [uploadedById], references: [id])
  uploadedById String?
  uploadedAt   DateTime   @default(now())
}

enum AttachmentCategory {
  GENERAL       // General work order documents
  INVOICE       // Customer invoices
  RECEIPT       // Payment receipts
  WARRANTY      // Warranty documents
  INSPECTION    // Inspection reports
  BEFORE_AFTER  // Before/after photos
  DIAGNOSTIC    // Diagnostic reports
  MANUAL        // Service manuals
  OTHER         // Other documents
}

model Payment {
  id           String     @id @default(cuid())
  workOrder    WorkOrder  @relation(fields: [workOrderId], references: [id])
  workOrderId  String
  method       PaymentMethod
  amount       Decimal    @db.Decimal(10,2)
  reference    String?    // Payment reference number
  status       PaymentStatus @default(PENDING)
  paidAt       DateTime   @default(now())
  processedBy  ServiceAdvisor? @relation("ProcessedPayments", fields: [processedById], references: [id])
  processedById String?
  notes        String?    // Payment notes
  refundAmount Decimal?   @db.Decimal(10,2) // For partial refunds
  refundReason String?    // Reason for refund
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
}

enum PaymentMethod {
  CASH
  CREDIT_CARD
  DEBIT_CARD
  BANK_TRANSFER
  UPI
  CHEQUE
  DIGITAL_WALLET
  INSURANCE
  WARRANTY
}

enum WorkflowStep {
  RECEIVED
  INSPECTION
  ESTIMATE
  APPROVAL
  REPAIR
  QC
  READY
  CLOSED
}

enum PaymentStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  OVERDUE
  COMPLETED
  FAILED
  REFUNDED
  PARTIAL_REFUND
  CANCELLED
}

enum ServiceStatus {
  ESTIMATED       // In estimate, awaiting customer approval
  PENDING         // Approved, waiting to start
  IN_PROGRESS     // Work in progress
  COMPLETED       // Work completed
  CANCELLED       // Cancelled
}

model WorkOrderService {
  id               String        @id @default(cuid())
  workOrder        WorkOrder     @relation(fields: [workOrderId], references: [id])
  workOrderId      String
  
  // Template reference (optional - can create custom services)
  cannedService    CannedService? @relation(fields: [cannedServiceId], references: [id])
  cannedServiceId  String?
  
  description      String        // Service description (e.g., "Oil Change Service - Honda Civic 2020")
  quantity         Int           @default(1)  // Can perform service multiple times
  
  // PRICING - This is where the customer is billed!
  unitPrice        Decimal       @db.Decimal(10,2)  // Price per service instance
  subtotal         Decimal       @db.Decimal(10,2)  // unitPrice × quantity
  
  // Customer approval status
  customerApproved Boolean       @default(false)
  customerRejected Boolean       @default(false)
  customerNotes    String?       // Customer feedback on this service
  
  // Timestamps
  approvedAt       DateTime?     // When customer approved
  rejectedAt       DateTime?     // When customer rejected
  
  status           ServiceStatus @default(ESTIMATED)
  notes            String?       // Internal notes
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  
  // Child labor items (for tracking work, NOT for pricing)
  laborItems       WorkOrderLabor[]
  
  @@index([workOrderId])
  @@index([customerApproved])
  @@index([status])
}


model InventoryCategory {
  id String @id @default(cuid())
  name String @unique
  
  // Relations
  inventoryItems InventoryItem[]
  cannedServices CannedServicePartsCategory[] // Services that use parts from this category
}

// Invoice System
enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
  CANCELLED
}

enum LineItemType {
  SERVICE
  LABOR
  PART
  DISCOUNT
  TAX
  OTHER
}

model Invoice {
  id              String        @id @default(cuid())
  invoiceNumber   String        @unique
  workOrder       WorkOrder     @relation(fields: [workOrderId], references: [id])
  workOrderId     String
  
  // Invoice Details
  issueDate       DateTime      @default(now())
  dueDate         DateTime?
  status          InvoiceStatus @default(DRAFT)
  
  // Pricing Breakdown
  subtotalServices Decimal     @db.Decimal(10,2) @default(0) // Sum of WorkOrderService subtotals
  subtotalLabor    Decimal     @db.Decimal(10,2) @default(0) // Sum of WorkOrderLabor subtotals  
  subtotalParts    Decimal     @db.Decimal(10,2) @default(0) // Sum of WorkOrderPart subtotals
  subtotal         Decimal     @db.Decimal(10,2) @default(0) // Total before tax/discount
  taxAmount        Decimal     @db.Decimal(10,2) @default(0)
  discountAmount   Decimal     @db.Decimal(10,2) @default(0)
  totalAmount      Decimal     @db.Decimal(10,2) @default(0)
  
  // Payment Info
  paidAmount      Decimal     @db.Decimal(10,2) @default(0)
  balanceDue      Decimal     @db.Decimal(10,2) @default(0)
  
  // Metadata
  notes           String?
  terms           String?
  pdfUrl          String?     // URL to generated PDF in Supabase Storage
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // Relations
  lineItems       InvoiceLineItem[]
}

model InvoiceLineItem {
  id          String    @id @default(cuid())
  invoice     Invoice   @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  invoiceId   String
  
  // Item Details
  type        LineItemType
  description String
  quantity    Int         @default(1)
  unitPrice   Decimal     @db.Decimal(10,2)
  subtotal    Decimal     @db.Decimal(10,2)
  
  // References to original items (optional - for tracking)
  workOrderServiceId String?
  workOrderLaborId   String?
  workOrderPartId    String?
  
  // Additional details
  notes       String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

// ============================================================================
// NOTIFICATION SYSTEM
// ============================================================================

model Notification {
  id          String    @id @default(cuid())
  userProfile UserProfile @relation(fields: [userProfileId], references: [id], onDelete: Cascade)
  userProfileId String
  workOrder   WorkOrder? @relation(fields: [workOrderId], references: [id], onDelete: SetNull)
  workOrderId String?
  
  // Notification Details
  type        NotificationType
  title       String
  message     String    @db.Text
  priority    NotificationPriority @default(NORMAL)
  
  // Read/Unread Status
  isRead      Boolean   @default(false)
  readAt      DateTime?
  
  // Action URL (for deep linking)
  actionUrl   String?
  actionText  String?
  
  // Metadata (JSON field for flexible data storage)
  metadata    Json?
  
  // Channels used
  sentViaEmail Boolean  @default(false)
  sentViaPush  Boolean  @default(false)
  
  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  expiresAt   DateTime? // Optional expiration date
  
  @@index([userProfileId])
  @@index([workOrderId])
  @@index([isRead])
  @@index([createdAt])
  @@index([userProfileId, isRead])
}

enum NotificationType {
  WORK_ORDER_CREATED
  WORK_ORDER_STATUS_CHANGED
  WORK_ORDER_COMPLETED
  SERVICE_APPROVAL_REQUIRED
  SERVICE_APPROVED
  SERVICE_REJECTED
  PART_APPROVAL_REQUIRED
  PART_APPROVED
  PART_REJECTED
  INSPECTION_COMPLETED
  INSPECTION_ISSUE_FOUND
  PAYMENT_RECEIVED
  INVOICE_GENERATED
  APPOINTMENT_CONFIRMED
  APPOINTMENT_REMINDER
  APPOINTMENT_CANCELLED
  VEHICLE_READY_FOR_PICKUP
  QC_PASSED
  QC_FAILED
  PROMOTIONAL
  SYSTEM_ALERT
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum NotificationChannel {
  EMAIL
  PUSH
  IN_APP
}

enum NotificationDeliveryStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  BOUNCED
  CLICKED
  READ
}
